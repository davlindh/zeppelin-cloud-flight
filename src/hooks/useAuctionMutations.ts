import { useState } from 'react';
import { useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import type { Auction } from '@/types/unified';

interface CreateAuctionData {
  title: string;
  starting_bid: number;
  end_time: string; // ISO string
  category: 'electronics' | 'fashion' | 'home' | 'sports' | 'books' | 'art' | 'collectibles' | 'automotive';
  condition: 'new' | 'like-new' | 'good' | 'fair' | 'poor';
  image: string;
  images?: string[];
  category_name?: string;
  reserve_price?: number;
  description?: string;
}

interface UpdateAuctionData extends Partial<CreateAuctionData> {
  id: string;
  current_bid?: number;
}

export const useAuctionMutations = () => {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const queryClient = useQueryClient();

  const createAuction = async (auctionData: CreateAuctionData): Promise<Auction | null> => {
    setIsLoading(true);
    setError(null);

    try {
      // Validate end time is in the future
      const endTime = new Date(auctionData.end_time);
      if (endTime <= new Date()) {
        throw new Error('Auction end time must be in the future');
      }

      // Prepare data for database
      const dbData = {
        title: auctionData.title,
        starting_bid: auctionData.starting_bid,
        current_bid: auctionData.starting_bid, // Start with starting bid
        end_time: auctionData.end_time,
        bidders: 0,
        category: auctionData.category,
        condition: auctionData.condition,
        image: auctionData.image,
        images: auctionData.images || [auctionData.image],
        category_name: auctionData.category_name,
        slug: null, // Will be generated by database
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      };

      console.log('üîÑ Creating auction with data:', dbData);

      const { data, error } = await supabase
        .from('auctions')
        .insert([dbData])
        .select()
        .single();

      if (error) {
        console.error('‚ùå Auction creation error:', error);
        throw new Error(`Failed to create auction: ${error.message}`);
      }

      console.log('‚úÖ Auction created successfully:', data);

      // Invalidate auctions query to refresh the list
      await queryClient.invalidateQueries({ queryKey: ['auctions'] });

      // Transform database response to Auction type
      const auction: Auction = {
        id: data.id,
        title: data.title,
        currentBid: data.current_bid,
        startingBid: data.starting_bid,
        endTime: new Date(data.end_time),
        bidders: data.bidders,
        category: data.category,
        condition: data.condition,
        image: data.image,
        slug: data.slug ?? undefined,
        created_at: data.created_at,
        updated_at: data.updated_at
      };

      return auction;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred';
      console.error('‚ùå Create auction error:', errorMessage);
      setError(errorMessage);
      return null;
    } finally {
      setIsLoading(false);
    }
  };

  const updateAuction = async (auctionData: UpdateAuctionData): Promise<Auction | null> => {
    setIsLoading(true);
    setError(null);

    try {
      // Prepare update data (only include fields that are provided)
      const updateFields: any = {
        updated_at: new Date().toISOString()
      };

      if (auctionData.title) updateFields.title = auctionData.title;
      if (auctionData.starting_bid !== undefined) updateFields.starting_bid = auctionData.starting_bid;
      if (auctionData.current_bid !== undefined) updateFields.current_bid = auctionData.current_bid;
      if (auctionData.end_time) {
        const endTime = new Date(auctionData.end_time);
        if (endTime <= new Date()) {
          throw new Error('Auction end time must be in the future');
        }
        updateFields.end_time = auctionData.end_time;
      }
      if (auctionData.category) updateFields.category = auctionData.category;
      if (auctionData.condition) updateFields.condition = auctionData.condition;
      if (auctionData.image) updateFields.image = auctionData.image;
      if (auctionData.images) updateFields.images = auctionData.images;

      console.log('üîÑ Updating auction:', auctionData.id, 'with data:', updateFields);

      const { data, error } = await supabase
        .from('auctions')
        .update(updateFields)
        .eq('id', auctionData.id)
        .select()
        .maybeSingle();

      if (error) {
        console.error('‚ùå Auction update error:', error);
        throw new Error(`Failed to update auction: ${error.message}`);
      }

      if (!data) {
        throw new Error('Auction not found or update failed');
      }

      console.log('‚úÖ Auction updated successfully:', data);

      // Invalidate auctions query to refresh the list
      await queryClient.invalidateQueries({ queryKey: ['auctions'] });

      // Transform database response to Auction type
      const auction: Auction = {
        id: data.id,
        title: data.title,
        currentBid: data.current_bid,
        startingBid: data.starting_bid,
        endTime: new Date(data.end_time),
        bidders: data.bidders,
        category: data.category,
        condition: data.condition,
        image: data.image,
        slug: data.slug ?? undefined,
        created_at: data.created_at,
        updated_at: data.updated_at
      };

      return auction;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred';
      console.error('‚ùå Update auction error:', errorMessage);
      setError(errorMessage);
      return null;
    } finally {
      setIsLoading(false);
    }
  };

  const endAuction = async (auctionId: string, force: boolean = false): Promise<boolean> => {
    setIsLoading(true);
    setError(null);

    try {
      console.log('üîÑ Ending auction:', auctionId, force ? '(forced)' : '');

      // If forcing end, set end_time to now
      const updateData = force 
        ? { 
            end_time: new Date().toISOString(),
            updated_at: new Date().toISOString()
          }
        : {
            updated_at: new Date().toISOString()
          };

      const { error } = await supabase
        .from('auctions')
        .update(updateData)
        .eq('id', auctionId);

      if (error) {
        console.error('‚ùå Auction end error:', error);
        throw new Error(`Failed to end auction: ${error.message}`);
      }

      console.log('‚úÖ Auction ended successfully:', auctionId);

      // Invalidate auctions query to refresh the list
      await queryClient.invalidateQueries({ queryKey: ['auctions'] });

      return true;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred';
      console.error('‚ùå End auction error:', errorMessage);
      setError(errorMessage);
      return false;
    } finally {
      setIsLoading(false);
    }
  };

  const extendAuction = async (auctionId: string, additionalMinutes: number): Promise<boolean> => {
    setIsLoading(true);
    setError(null);

    try {
      console.log('üîÑ Extending auction:', auctionId, 'by', additionalMinutes, 'minutes');

      // First get current auction data
      const { data: currentData, error: fetchError } = await supabase
        .from('auctions')
        .select('end_time')
        .eq('id', auctionId)
        .single();

      if (fetchError) {
        throw new Error(`Failed to fetch auction: ${fetchError.message}`);
      }

      // Calculate new end time
      const currentEndTime = new Date(currentData.end_time);
      const newEndTime = new Date(currentEndTime.getTime() + (additionalMinutes * 60 * 1000));

      const { error } = await supabase
        .from('auctions')
        .update({ 
          end_time: newEndTime.toISOString(),
          updated_at: new Date().toISOString()
        })
        .eq('id', auctionId);

      if (error) {
        console.error('‚ùå Auction extension error:', error);
        throw new Error(`Failed to extend auction: ${error.message}`);
      }

      console.log('‚úÖ Auction extended successfully:', auctionId, 'new end time:', newEndTime);

      // Invalidate auctions query to refresh the list
      await queryClient.invalidateQueries({ queryKey: ['auctions'] });

      return true;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred';
      console.error('‚ùå Extend auction error:', errorMessage);
      setError(errorMessage);
      return false;
    } finally {
      setIsLoading(false);
    }
  };

  const deleteAuction = async (auctionId: string): Promise<boolean> => {
    setIsLoading(true);
    setError(null);

    try {
      console.log('üîÑ Deleting auction:', auctionId);

      // First check if auction has bids
      const { data: bidData, error: bidError } = await supabase
        .from('bid_history')
        .select('id')
        .eq('auction_id', auctionId)
        .limit(1);

      if (bidError) {
        console.warn('Warning: Could not check bid history:', bidError);
      }

      if (bidData && bidData.length > 0) {
        throw new Error('Cannot delete auction with existing bids. Use "End Auction" instead.');
      }

      // Delete the auction
      const { error } = await supabase
        .from('auctions')
        .delete()
        .eq('id', auctionId);

      if (error) {
        console.error('‚ùå Auction deletion error:', error);
        throw new Error(`Failed to delete auction: ${error.message}`);
      }

      console.log('‚úÖ Auction deleted successfully:', auctionId);

      // Invalidate auctions query to refresh the list
      await queryClient.invalidateQueries({ queryKey: ['auctions'] });

      return true;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred';
      console.error('‚ùå Delete auction error:', errorMessage);
      setError(errorMessage);
      return false;
    } finally {
      setIsLoading(false);
    }
  };

  return {
    createAuction,
    updateAuction,
    endAuction,
    extendAuction,
    deleteAuction,
    isLoading,
    error,
    clearError: () => setError(null)
  };
};
